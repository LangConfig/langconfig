# Copyright (c) 2025 Cade Russell (Ghost Peony)
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.

"""
WorkflowState definition for the LangConfig LangGraph orchestration system.

This state object tracks the complete lifecycle of a development workflow,
from initial directive through execution, validation, and potential HITL intervention.

LangGraph v1.0 Best Practices:
- Uses Annotated types with reducers for automatic list accumulation
- Nodes return only NEW items, reducers handle concatenation
- Cleaner node logic and better parallelism support
"""

from typing import TypedDict, Optional, Dict, Any, List, Annotated
from datetime import datetime
from enum import Enum
import operator


class HandoffSummary(TypedDict):
    """Structured summary generated by an agent for context continuity."""
    task_id: int
    attempt: int
    actions_taken: List[str]
    rationale: str
    pending_items: List[str]
    status: str

class WorkflowStatus(str, Enum):
    """Enumeration of possible workflow states."""
    INITIALIZING = "INITIALIZING"
    PLANNING = "PLANNING" 
    EXECUTING = "EXECUTING"
    VALIDATING = "VALIDATING"
    PASSED = "PASSED"
    FAILED_EXECUTION = "FAILED_EXECUTION"
    FAILED_VALIDATION = "FAILED_VALIDATION"
    AWAITING_HITL = "AWAITING_HITL"
    HITL_REVIEWING = "HITL_REVIEWING"
    HITL_APPROVED = "HITL_APPROVED"
    HITL_REJECTED = "HITL_REJECTED"
    RETRYING = "RETRYING"
    TERMINATED = "TERMINATED"


class ClassificationType(str, Enum):
    """Types of development tasks that can be classified."""
    BACKEND = "BACKEND"
    FRONTEND = "FRONTEND"
    DEVOPS_IAC = "DEVOPS_IAC"
    DATABASE = "DATABASE"
    API = "API"
    TESTING = "TESTING"
    DOCUMENTATION = "DOCUMENTATION"
    CONFIGURATION = "CONFIGURATION"


class ExecutorType(str, Enum):
    """Available executor types for different kinds of tasks."""
    DEFAULT = "default"
    DEVOPS = "devops"
    FRONTEND = "frontend"
    DATABASE = "database"
    TESTING = "testing"


class WorkflowState(TypedDict):
    """
    Represents the complete state of a LangConfig development workflow.

    This state is persisted via LangGraph checkpointing to PostgreSQL,
    enabling durability and Human-in-the-Loop capabilities.

    ✅ LangGraph v1.0: Uses reducers for automatic list accumulation.
    Nodes can return ONLY new items: {"handoff_history": [new_handoff]}
    The reducer automatically appends to existing list.
    """

    # --- Core Identifiers and Configuration ---
    project_id: int
    task_id: int
    workflow_id: Optional[str]  # LangGraph thread ID
    classification: ClassificationType
    executor_type: ExecutorType
    max_retries: int

    # --- Input Data and Context ---
    original_directive: str
    current_directive: str  # Evolves during correction cycles

    # Messages for LangChain agent communication
    # ✅ REDUCER: Automatically appends new messages
    messages: Annotated[List[Any], operator.add]

    # Static Context (RAG/DNA)
    static_context_package: str

    # --- Dynamic Context (The Scratchpad) ---
    # The concise, synthesized text summary used in prompts
    workflow_scratchpad: str

    # ✅ REDUCER: Automatically appends new handoffs to history
    # Nodes return: {"handoff_history": [new_handoff]}
    handoff_history: Annotated[List[HandoffSummary], operator.add]

    # The latest summary generated by the last agent (temporary storage between nodes)
    latest_handoff: Optional[HandoffSummary]
    
    # --- Execution Tracking ---
    retry_count: int
    feature_branch_name: Optional[str]
    current_step: str  # Current node in the workflow graph
    workflow_initialized: Optional[bool]  # Tracks whether initialization completed
    execution_successful: Optional[bool]  # Tracks whether execution completed successfully
    execution_failed: Optional[bool]  # Tracks whether execution failed
    handoff_captured: Optional[bool]  # Tracks whether handoff summary was captured
    
    # --- Celery Task Integration ---
    active_celery_task_id: Optional[str]  # Current running Celery task
    celery_task_status: Optional[str]     # SUCCESS, FAILURE, PENDING, RETRY
    celery_task_result: Optional[Dict[str, Any]]  # Task execution results
    
    # --- Workflow Status and Results ---
    workflow_status: WorkflowStatus
    validation_report: Optional[Dict[str, Any]]
    execution_plan: Optional[str]  # For DevOps HITL scenarios
    error_message: Optional[str]   # Last error encountered
    
    # --- Human-in-the-Loop Data ---
    hitl_required: bool
    hitl_reason: Optional[str]     # Why HITL intervention is needed
    hitl_context: Optional[Dict[str, Any]]  # Additional context for human reviewer
    hitl_response: Optional[Dict[str, Any]]  # Human's decision/input
    
    # --- Timing and Metrics ---
    created_at: datetime
    updated_at: datetime
    started_at: Optional[datetime]
    completed_at: Optional[datetime]
    execution_duration_seconds: Optional[float]
    
    # --- Workflow History ---
    # ✅ REDUCER: Automatically appends new steps
    # Nodes return: {"step_history": [new_step]}
    step_history: Annotated[List[Dict[str, Any]], operator.add]

    # ✅ REDUCER: Automatically appends retry attempts
    # Nodes return: {"retry_history": [new_retry]}
    retry_history: Annotated[List[Dict[str, Any]], operator.add]

    # --- Output Artifacts ---
    # ✅ REDUCER: Automatically appends generated files
    # Nodes return: {"generated_files": [new_file]}
    generated_files: Annotated[List[Dict[str, str]], operator.add]

    # ✅ REDUCER: Automatically appends commit hashes
    # Nodes return: {"git_commits": [new_commit_hash]}
    git_commits: Annotated[List[str], operator.add]

    deployment_info: Optional[Dict[str, Any]]  # For DevOps workflows
    
    # --- Strategy-Specific State ---
    # Flexible container for strategy-specific data (e.g., Roman Legion tier info)
    strategy_state: Dict[str, Any]


# State update helper functions
def create_initial_state(
    project_id: int,
    task_id: int,
    directive: str,
    static_context_package: str,
    classification: ClassificationType,
    executor_type: ExecutorType = ExecutorType.DEFAULT,
    max_retries: int = 3
) -> WorkflowState:
    """Create an initial workflow state for a new task."""
    now = datetime.utcnow()
    
    return WorkflowState(
        # Core identifiers
        project_id=project_id,
        task_id=task_id,
        workflow_id=None,
        classification=classification,
        executor_type=executor_type,
        max_retries=max_retries,
        
        # Input data
        original_directive=directive,
        current_directive=directive,
        messages=[],  # LangChain messages for agent communication
        # Static + Dynamic Context
        static_context_package=static_context_package,
        workflow_scratchpad="",  # starts empty and grows with execution
        handoff_history=[],
        latest_handoff=None,
        
        # Execution tracking
        retry_count=0,
        feature_branch_name=None,
        current_step="initialize",
        workflow_initialized=None,
        execution_successful=None,
        execution_failed=None,
        handoff_captured=None,
        
        # Celery integration
        active_celery_task_id=None,
        celery_task_status=None,
        celery_task_result=None,
        
        # Status
        workflow_status=WorkflowStatus.INITIALIZING,
        validation_report=None,
        execution_plan=None,
        error_message=None,
        
        # HITL
        hitl_required=False,
        hitl_reason=None,
        hitl_context=None,
        hitl_response=None,
        
        # Timing
        created_at=now,
        updated_at=now,
        started_at=None,
        completed_at=None,
        execution_duration_seconds=None,
        
        # History
        step_history=[],
        retry_history=[],
        
        # Artifacts
        generated_files=[],
        git_commits=[],
        deployment_info=None,
        
        # Strategy-specific state
        strategy_state={}  # Empty dict, populated by strategy handlers
    )


def update_workflow_status(
    state: WorkflowState,
    status: WorkflowStatus,
    current_step: Optional[str] = None,
    error_message: Optional[str] = None
) -> Dict[str, Any]:
    """
    Create state update to change workflow status.

    ✅ LangGraph v1.0: Returns ONLY the updates, not full state.
    The reducer automatically appends to step_history.

    Args:
        state: The current workflow state (for reading context)
        status: New workflow status
        current_step: Optional step name
        error_message: Optional error message

    Returns:
        Dictionary with state updates
    """
    now = datetime.utcnow()

    # Build updates dictionary
    updates = {
        "workflow_status": status,
        "updated_at": now
    }

    if current_step:
        updates["current_step"] = current_step

    if error_message:
        updates["error_message"] = error_message

    # Set timing markers
    if status == WorkflowStatus.EXECUTING and not state.get("started_at"):
        updates["started_at"] = now
    elif status in [WorkflowStatus.PASSED, WorkflowStatus.TERMINATED, WorkflowStatus.FAILED_EXECUTION, WorkflowStatus.FAILED_VALIDATION]:
        if not state.get("completed_at"):
            updates["completed_at"] = now
            if state.get("started_at"):
                updates["execution_duration_seconds"] = (now - state["started_at"]).total_seconds()

    # ✅ Add to step history (reducer appends automatically)
    updates["step_history"] = [{
        "step": current_step or state.get("current_step", "unknown"),
        "status": status.value,
        "timestamp": now.isoformat(),
        "error_message": error_message
    }]

    return updates


def add_retry_attempt(state: WorkflowState, reason: str) -> Dict[str, Any]:
    """
    Create state update to record a retry attempt.

    ✅ LangGraph v1.0: Returns ONLY the updates.
    The reducer automatically appends to retry_history.

    Args:
        state: The current workflow state (for reading context)
        reason: Reason for retry

    Returns:
        Dictionary with state updates
    """
    new_retry_count = state.get("retry_count", 0) + 1

    return {
        "retry_count": new_retry_count,
        # ✅ Reducer appends this automatically
        "retry_history": [{
            "attempt": new_retry_count,
            "reason": reason,
            "timestamp": datetime.utcnow().isoformat()
        }]
    }


def create_handoff_summary(
    task_id: int,
    attempt: int,
    actions_taken: List[str],
    rationale: str,
    pending_items: List[str],
    status: str
) -> HandoffSummary:
    """Create a structured handoff summary for context continuity."""
    return HandoffSummary(
        task_id=task_id,
        attempt=attempt,
        actions_taken=actions_taken,
        rationale=rationale,
        pending_items=pending_items,
        status=status
    )


def add_handoff_to_state(
    state: WorkflowState,
    handoff: HandoffSummary,
    compacted_scratchpad: Optional[str] = None
) -> Dict[str, Any]:
    """
    Create state update to add a handoff summary.

    ✅ LangGraph v1.0: Returns ONLY the updates, not full state.
    The reducer automatically appends handoff to handoff_history.

    Args:
        state: The current workflow state (for reading context)
        handoff: The handoff summary to add
        compacted_scratchpad: Optional pre-compacted scratchpad text

    Returns:
        Dictionary with state updates (not full state)

    Example:
        >>> updates = add_handoff_to_state(state, new_handoff)
        >>> # Reducer automatically appends to handoff_history
        >>> # returns: {"handoff_history": [new_handoff], "latest_handoff": new_handoff, ...}
    """
    # Build the update dictionary
    updates = {
        # ✅ Reducer appends this automatically
        "handoff_history": [handoff],
        "latest_handoff": handoff,
        "updated_at": datetime.utcnow()
    }

    # Update scratchpad
    if compacted_scratchpad is not None:
        updates["workflow_scratchpad"] = compacted_scratchpad
    else:
        # Simple append - this will be replaced by smart compaction logic
        current_count = len(state.get("handoff_history", []))
        new_entry = f"\nStep {current_count + 1}: {handoff['status']} - {handoff['rationale']}"
        updates["workflow_scratchpad"] = state.get("workflow_scratchpad", "") + new_entry

    return updates


def get_context_for_prompt(
    state: WorkflowState,
    include_static: bool = True,
    include_scratchpad: bool = True
) -> str:
    """Compile context for LLM prompts.
    
    This function combines static context (RAG/DNA) with the dynamic
    workflow scratchpad to create the full context for agent prompts.
    """
    context_parts = []
    
    if include_static and state["static_context_package"]:
        context_parts.append("=== STATIC CONTEXT (Project DNA + RAG) ===")
        context_parts.append(state["static_context_package"])
    
    if include_scratchpad and state["workflow_scratchpad"]:
        context_parts.append("=== WORKFLOW SCRATCHPAD (Previous Actions) ===")
        context_parts.append(state["workflow_scratchpad"])
    
    return "\n\n".join(context_parts)
